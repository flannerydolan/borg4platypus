From 14a3876746a18a1293faa999ce54b283463c90ad Mon Sep 17 00:00:00 2001
From: jack <jackjackk@gmail.com>
Date: Wed, 13 Sep 2017 22:15:26 -0400
Subject: [PATCH] patched BitBucket master to work w/ Python 3.6 &
 borg4platypus

---
 plugins/Python/borg.py | 77 ++++++++++++++++++++++++++++++++------------------
 plugins/Python/test.py |  2 +-
 2 files changed, 51 insertions(+), 28 deletions(-)

diff --git a/plugins/Python/borg.py b/plugins/Python/borg.py
index 52481de..f571971 100644
--- a/plugins/Python/borg.py
+++ b/plugins/Python/borg.py
@@ -111,15 +111,18 @@ class Configuration:
                 if os.name == "nt":
                     Configuration.libborg = WinDLL(path)
                     Configuration.stdcall = True
+        elif sys.platform == "darwin":
+            Configuration.libborg = CDLL("libborg.dylib")
+            Configuration.stdcall = False
         elif os.name == "posix":
             try:
-                Configuration.libborg = CDLL("./libborg.so")
+                Configuration.libborg = CDLL("libborg.so")
                 Configuration.stdcall = False
             except OSError:
                 return
         elif os.name == "nt":
             try:
-                Configuration.libborg = CDLL("./borg.dll")
+                Configuration.libborg = CDLL("borg.dll")
                 Configuration.libborg.BORG_Copyright
                 Configuration.stdcall = False
             except OSError:
@@ -127,7 +130,7 @@ class Configuration:
             except AttributeError:
                 # Not using __cdecl, try __stdcall instead
                 try:
-                    Configuration.libborg = WinDLL("./borg.dll")
+                    Configuration.libborg = WinDLL("borg.dll")
                     Configuration.stdcall = True
                 except OSError:
                     return
@@ -146,7 +149,7 @@ class Configuration:
         if value:
             Configuration.libborg.BORG_Random_seed(c_ulong(value))
         else:
-            Configuration.libborg.BORG_Random_seed(c_ulong(os.getpid()*long(time.time())))
+            Configuration.libborg.BORG_Random_seed(c_ulong(os.getpid()*int(time.time())))
 
     @staticmethod
     def enableDebugging():
@@ -180,10 +183,10 @@ class Configuration:
         except AttributeError:
             # The serial Borg MOEA C library is loaded; switch to parallel
             try:
-                Configuration.setBorgLibrary("./libborgmm.so")
+                Configuration.setBorgLibrary("libborgmm.so")
             except OSError:
                 try:
-                    Configuration.setBorgLibrary("./libborgms.so")
+                    Configuration.setBorgLibrary("libborgms.so")
                 except OSError:
                     raise OSError("Unable to locate the parallel Borg MOEA C library")
 
@@ -196,11 +199,14 @@ class Configuration:
         argv = CHARPP()
 
         for i in range(len(sys.argv)):
-            argv[i] = sys.argv[i]
+            argv[i] = sys.argv[i].encode('ascii')
 
         Configuration.libborg.BORG_Algorithm_ms_startup(
-            cast(addressof(argc), POINTER(c_int)),
-            cast(addressof(argv), POINTER(CHARPP)))
+            POINTER(c_int)(),
+            POINTER(CHARPP)()
+            #cast(addressof(argc), POINTER(c_int)),
+            #cast(addressof(argv), POINTER(CHARPP)))
+        )
 
         Configuration.startedMPI = True
 
@@ -307,6 +313,7 @@ class Borg:
             self.CMPFUNC = CFUNCTYPE(c_int, POINTER(c_double), POINTER(c_double), POINTER(c_double))
 
         self.callback = self.CMPFUNC(self.function)
+        Configuration.libborg.BORG_Problem_create.restype = c_void_p
         self.reference = c_void_p(Configuration.libborg.BORG_Problem_create(numberOfVariables, numberOfObjectives, numberOfConstraints, self.callback))
 
         if bounds:
@@ -373,7 +380,7 @@ class Borg:
         Configuration.libborg.BORG_Problem_set_bounds(self.reference, index, c_double(lowerBound), c_double(upperBound))
 
     def solveMPI(self, islands=1, maxTime=None, maxEvaluations=None, initialization=None, runtime=None,
-            allEvaluations=None):
+            allEvaluations=None, frequency=None):
         """ Runs the master-slave or multi-master Borg MOEA using MPI.
 
         islands        - The number of islands
@@ -385,6 +392,7 @@ class Borg:
         allEvaluations - Filename pattern for saving all evaluations (the filename should include
                          one %d which gets replaced by the island index).  Since this can quickly
                          generate large files, use this option with caution.
+        frequency      - The number of function evaluations between runtime outputs
         
         Note: All nodes must invoke solveMPI.  However, only one node will return the discovered
         Pareto optimal solutions.  The rest will return None.
@@ -412,15 +420,19 @@ class Borg:
             Configuration.libborg.BORG_Algorithm_ms_max_evaluations(c_int(maxEvaluations))
 
         if initialization and islands > 1:
-            Configuration.libborg.BORG_Algorithm_ms_initialization(c_int(initialization));
+            Configuration.libborg.BORG_Algorithm_ms_initialization(c_int(initialization))
 
         if runtime:
-            Configuration.libborg.BORG_Algorithm_output_runtime(c_char_p(runtime));
+            Configuration.libborg.BORG_Algorithm_output_runtime(c_char_p(runtime.encode()));
+
+        if frequency:
+            Configuration.libborg.BORG_Algorithm_output_frequency(c_int(frequency));
 
         if allEvaluations:
             Configuration.libborg.BORG_Algorithm_output_evaluations(c_char_p(allEvaluations));
 
-        result = Configuration.libborg.BORG_Algorithm_ms_run(self.reference)
+        Configuration.libborg.BORG_Algorithm_ms_run.restype = c_void_p
+        result = c_void_p(Configuration.libborg.BORG_Algorithm_ms_run(self.reference))
 
         return Result(result, self) if result else None
 
@@ -438,36 +450,37 @@ class Borg:
 
         maxEvaluations = settings.get("maxEvaluations", 10000)
         start = time.clock()
-
-        pm = Configuration.libborg.BORG_Operator_create("PM", 1, 1, 2, Configuration.libborg.BORG_Operator_PM)
+        Configuration.libborg.BORG_Operator_create.restype = c_void_p
+        pm = c_void_p(Configuration.libborg.BORG_Operator_create("PM", 1, 1, 2, Configuration.libborg.BORG_Operator_PM))
         Configuration.libborg.BORG_Operator_set_parameter(pm, 0, c_double(settings.get("pm.rate", 1.0 / self.numberOfVariables)))
         Configuration.libborg.BORG_Operator_set_parameter(pm, 1, c_double(settings.get("pm.distributionIndex", 20.0)))
         
-        sbx = Configuration.libborg.BORG_Operator_create("SBX", 2, 2, 2, Configuration.libborg.BORG_Operator_SBX)
+        sbx = c_void_p(Configuration.libborg.BORG_Operator_create("SBX", 2, 2, 2, Configuration.libborg.BORG_Operator_SBX))
         Configuration.libborg.BORG_Operator_set_parameter(sbx, 0, c_double(settings.get("sbx.rate", 1.0)))
         Configuration.libborg.BORG_Operator_set_parameter(sbx, 1, c_double(settings.get("sbx.distributionIndex", 15.0)))
         Configuration.libborg.BORG_Operator_set_mutation(sbx, pm)
 
-        de = Configuration.libborg.BORG_Operator_create("DE", 4, 1, 2, Configuration.libborg.BORG_Operator_DE)
+        de = c_void_p(Configuration.libborg.BORG_Operator_create("DE", 4, 1, 2, Configuration.libborg.BORG_Operator_DE))
         Configuration.libborg.BORG_Operator_set_parameter(de, 0, c_double(settings.get("de.crossoverRate", 0.1)))
         Configuration.libborg.BORG_Operator_set_parameter(de, 1, c_double(settings.get("de.stepSize", 0.5)))
         Configuration.libborg.BORG_Operator_set_mutation(de, pm)
 
-        um = Configuration.libborg.BORG_Operator_create("UM", 1, 1, 1, Configuration.libborg.BORG_Operator_UM)
+        um = c_void_p(Configuration.libborg.BORG_Operator_create("UM", 1, 1, 1, Configuration.libborg.BORG_Operator_UM))
         Configuration.libborg.BORG_Operator_set_parameter(um, 0, c_double(settings.get("um.rate", 1.0 / self.numberOfVariables)))
 
-        spx = Configuration.libborg.BORG_Operator_create("SPX", c_int(settings.get("spx.parents", 10)), c_int(settings.get("spx.offspring", 2)), 1, Configuration.libborg.BORG_Operator_SPX)
+        spx = c_void_p(Configuration.libborg.BORG_Operator_create("SPX", c_int(settings.get("spx.parents", 10)), c_int(settings.get("spx.offspring", 2)), 1, Configuration.libborg.BORG_Operator_SPX))
         Configuration.libborg.BORG_Operator_set_parameter(spx, 0, c_double(settings.get("spx.epsilon", 3.0)))
 
-        pcx = Configuration.libborg.BORG_Operator_create("PCX", c_int(settings.get("pcx.parents", 10)), c_int(settings.get("pcx.offspring", 2)), 2, Configuration.libborg.BORG_Operator_PCX)
+        pcx = c_void_p(Configuration.libborg.BORG_Operator_create("PCX", c_int(settings.get("pcx.parents", 10)), c_int(settings.get("pcx.offspring", 2)), 2, Configuration.libborg.BORG_Operator_PCX))
         Configuration.libborg.BORG_Operator_set_parameter(pcx, 0, c_double(settings.get("pcx.eta", 0.1)))
         Configuration.libborg.BORG_Operator_set_parameter(pcx, 1, c_double(settings.get("pcx.zeta", 0.1)))
 
-        undx = Configuration.libborg.BORG_Operator_create("UNDX", c_int(settings.get("undx.parents", 10)), c_int(settings.get("undx.offspring", 2)), 2, Configuration.libborg.BORG_Operator_UNDX)
+        undx = c_void_p(Configuration.libborg.BORG_Operator_create("UNDX", c_int(settings.get("undx.parents", 10)), c_int(settings.get("undx.offspring", 2)), 2, Configuration.libborg.BORG_Operator_UNDX))
         Configuration.libborg.BORG_Operator_set_parameter(undx, 0, c_double(settings.get("undx.zeta", 0.5)))
         Configuration.libborg.BORG_Operator_set_parameter(undx, 1, c_double(settings.get("undx.eta", 0.35)))
 
-        algorithm = Configuration.libborg.BORG_Algorithm_create(self.reference, 6)
+        Configuration.libborg.BORG_Algorithm_create.restype = c_void_p
+        algorithm = c_void_p(Configuration.libborg.BORG_Algorithm_create(self.reference, 6))
         Configuration.libborg.BORG_Algorithm_set_operator(algorithm, 0, sbx)
         Configuration.libborg.BORG_Algorithm_set_operator(algorithm, 1, de)
         Configuration.libborg.BORG_Algorithm_set_operator(algorithm, 2, pcx)
@@ -542,7 +555,8 @@ class Borg:
                 if fp is None:
                     statistics.append(entry)
                 else:
-                    archive = Result(Configuration.libborg.BORG_Algorithm_get_result(algorithm), self, statistics)
+                    Configuration.libborg.BORG_Algorithm_get_result.restype = c_void_p
+                    archive = Result(c_void_p(Configuration.libborg.BORG_Algorithm_get_result(algorithm)), self, statistics)
                     if runtimeformat == 'optimizedv':
                         row = ["{0}".format(entry[dynamic]) for dynamic in dynamics_header]
                         fp.write("//")
@@ -586,7 +600,8 @@ class Borg:
 
                 lastSnapshot = currentEvaluations
 
-        result = Configuration.libborg.BORG_Algorithm_get_result(algorithm)
+        Configuration.libborg.BORG_Algorithm_get_result.restype = c_void_p
+        result = c_void_p(Configuration.libborg.BORG_Algorithm_get_result(algorithm))
         if "runtimefile" in settings:
             fp.close()
 
@@ -643,7 +658,7 @@ class Solution:
 
     def display(self, out=sys.stdout, separator=" "):
         """ Prints the decision variables, objectives, and constraints to standard output. """
-        print >> out, separator.join(map(str, self.getVariables() + self.getObjectives() + self.getConstraints()))
+        print(separator.join(map(str, self.getVariables() + self.getObjectives() + self.getConstraints())), file=out, end='\n')
 
     def violatesConstraints(self):
         """ Returns True if this solution violates one or more constraints; False otherwise. """
@@ -677,7 +692,8 @@ class Result:
 
     def get(self, index):
         """ Returns the Pareto optimal solution at the given index. """
-        return Solution(Configuration.libborg.BORG_Archive_get(self.reference, index), self.problem)
+        Configuration.libborg.BORG_Archive_get.restype = c_void_p
+        return Solution(c_void_p(Configuration.libborg.BORG_Archive_get(self.reference, index)), self.problem)
 
 class ResultIterator:
     """ Iterates over the solutions in a Pareto optimal set. """
@@ -687,7 +703,10 @@ class ResultIterator:
         self.result = result
         self.index = -1
 
-    def next(self):
+    def __iter__(self):
+        return self
+
+    def __next__(self):
         """ Returns the next Pareto optimal solution in the set. """
         self.index = self.index + 1
 
@@ -696,6 +715,10 @@ class ResultIterator:
         else:
             return self.result.get(self.index)
 
+    def next(self):
+        return self.__next__()
+
+
 def _functionWrapper(function, numberOfVariables, numberOfObjectives, numberOfConstraints, directions=None):
     """ Wraps a Python evaluation function and converts it to the function signature
     required by the C API.
diff --git a/plugins/Python/test.py b/plugins/Python/test.py
index 0e828e5..bf36700 100644
--- a/plugins/Python/test.py
+++ b/plugins/Python/test.py
@@ -29,5 +29,5 @@ borg.setEpsilons(*[0.01]*nobjs)
 result = borg.solve({"maxEvaluations":1000000})
 
 for solution in result:
-	print solution.getObjectives()
+	print(solution.getObjectives())
 
-- 
2.14.1

